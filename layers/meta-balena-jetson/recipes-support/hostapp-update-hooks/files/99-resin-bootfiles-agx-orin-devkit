#!/bin/sh
set -o errexit

# Script which writes the appropriate
# device tree with embedded cmdline
# and updates the kernel, as well as
# the rest of the bootloader binaries
. /usr/libexec/os-helpers-fs
. /usr/sbin/balena-config-vars
source /usr/bin/uefi_common.func

DURING_UPDATE=${DURING_UPDATE:-0}
bootloader_blob="/opt/tegra-binaries/TEGRA_BL_3701.Cap.gz"
bootloader_device="/dev/mtdblock0"
internal_storage="/dev/mmcblk0"
use_capsule=1
efivars_dir="/sys/firmware/efi/efivars/"
# See https://github.com/OE4T/meta-tegra/blob/master/recipes-bsp/tools/setup-nv-boot-control/setup-nv-boot-control.sh.in
platform_spec_efivar="${efivars_dir}TegraPlatformSpec-781e084c-a330-417c-b678-38e696380cb9"
platform_compat_spec_efivar="${efivars_dir}TegraPlatformCompatSpec-781e084c-a330-417c-b678-38e696380cb9"
os_indications_efivar="${efivars_dir}OsIndications-8be4df61-93ca-11d2-aa0d-00e098032b8c"
tmp_file="/tmp/platformspecfile.bin"
device_type="jetson-agx-orin-devkit"
boardspec=$(tegra-boardspec 2>/dev/null)
TegraPlatformSpec="${boardspec}-${device_type}-"
compatspec=$(echo "$boardspec" | gen_compat_spec)
TegraPlatformCompatSpec="${compatspec}-${device_type}-"

get_board_sku() {
    IFS=- read boardid fab boardsku boardrev fuselevel chiprev
    if gen_compat_$boardid 2>/dev/null; then
        echo "$boardsku"
        return 0
    fi
    echo ""
}

write_jetson_update_efivars() {
    info "Writing of jetson efivars triggered from old OS hook"
    if [ -d $efivars_dir ]; then
        # If the file already exists, writing to it will fail
        # causing the entire hook to fail
        if [ ! -e ${platform_spec_efivar} ]; then
            printf "\x07\x00\x00\x00" > ${tmp_file}
            printf "%s" "${TegraPlatformSpec}" >> ${tmp_file}
            dd if=${tmp_file} of=${platform_spec_efivar}
            info "PlatformSpec variable created"
        else
            info "PlatformSpec variable already exists"
        fi

        if [ ! -e ${platform_compat_spec_efivar} ]; then
            printf "\x07\x00\x00\x00" > ${tmp_file}
            printf "%s" "${TegraPlatformCompatSpec}" >> ${tmp_file}
            dd if=${tmp_file} of=${platform_compat_spec_efivar}
            info "PlatformCompatSpec variable created"
        else
            info "PlatformCompatSpec variable already exists"
        fi

        printf "%b" '\x07\x00\x00\x00\x04\x00\x00\x00\x00\x00\x00\x00' > ${tmp_file}
        dd if=${tmp_file} of=${os_indications_efivar}
        info "OsIndications variable written"
    else
        fail "sysfs not accessible!"
        return 1
    fi

    return 0
}

check_disable_xudc()
{
    extlinuxfile="/mnt/sysroot/active/current/boot/extlinux/extlinux.conf"

    if [ -e $extlinuxfile ]; then
       if grep -q "l4tver=35.1.0" "${extlinuxfile}"; then
            info "Old root is running L4T 35.1.0, will disable tegra-xudc from the device-trees"
            use_capsule=0
            for dtbfile in `find /mnt/sysroot/active/ -name "*.dtb" -type f`; do
                info "Disabling tegra-xudc in $dtbfile ...";
                fdtput -t s $dtbfile /xudc status disabled
                fdtput -t s $dtbfile / nvidia,dtsfilename "tegra234-p3701-0000-p3737-0000_xudc_disabled.dts"
                current_xudc_status=$(fdtget $dtbfile /xudc status)
                info "$dtbfile now has xudc $current_xudc_status"
            done
        else
            info "extlinux file not found in old rootfs"
        fi;
    fi;
}

check_corrupted_slots()
{
    # Only the alternate slot can be corrupt, otherwise this script
    # wouldn't be running because the device wouldn't boot
    if nvbootctrl dump-slots-info | grep -q unbootable ; then
	warn "alternate boot slot is unbootable and will require legacy boot blob update"
        # 32GB units have SKUs 0000 and 0004 - see https://forums.developer.nvidia.com/t/which-agx-orin-i-have/276195/10
        # We avoid sku 0005, because it's a 64GB and the boot blob
        # is taken from a 32GB Devkit. This image shouldn't be
        # used with 64GB units in production anyway.

        boardsku=$(echo "$boardspec" | get_board_sku)

        if [ "$boardsku" = "0000" -o "$boardsku" = "0004" ]; then
	    info "Will use legacy mode update for boot firmware because the UEFI capsule cannot be applied in the current state"
            use_capsule=0
	else
	    fail "Running on a non 32GB AGX Orin model with corrupt alternate slots. Cannot proceed with boot firmware update"
	fi
    fi
}

check_and_update_esp_flags() {
    esp_type="C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
    esp_index="5"
    resin_boot_index="6"

    esp_part_type=$(sfdisk --part-type $internal_storage $esp_index)
    resin_boot_part_type=$(sfdisk --part-type $internal_storage $resin_boot_index)

    if [ "$esp_type" != "$esp_part_type" ]; then
        info "type change needed on esp partition"
	sfdisk --part-type $internal_storage $esp_index $esp_type
	sync
    else
        info "ok - esp partition has esp flag"
    fi

    if [ "$resin_boot_part_type" != "$esp_type" ]; then
        info "resin-boot partition does not have esp type, must be added"
        sfdisk --part-type $internal_storage $resin_boot_index $esp_type
        sync
    else
        info "no type change needed on resin-boot partition"
    fi
}

check_disable_xudc

info "Bootloader blob is $bootloader_blob"

# This allows for writing UEFI variables
# in L4T 36.3, in the case where the hook
# is triggered by the rollback-health script
unload_spi_drivers() {
spi_modules=("spi_tegra210_quad" "spi_tegra114")

for spi_module in "${spi_modules[@]}"
do
    if lsmod | grep -q $spi_module ; then
        info "Unloading $spi_module"
        rmmod $spi_module

        if [ $? -eq 0 ]; then
            info "Unloaded $spi_module"
        fi
    fi
done
}

# Unload SPI drivers before any
# nvbootctrl call. When running in L4T
# 36.3, this is mandatory to avoid
# system hangs.
unload_spi_drivers

do_capsule_update() {
    esp_dev=$(get_state_path_from_label "esp")
    esp_tmp_dir="/tmp/esp/"
    capsule_dir="/EFI/UpdateCapsule/"
    /usr/sbin/mkfs.vfat ${esp_dev}
    mkdir -p ${esp_tmp_dir}
    mount ${esp_dev} ${esp_tmp_dir}
    mkdir -p "${esp_tmp_dir}${capsule_dir}"
    # Unzip capsule to the esp partition, because the uncompressed capsule size
    # is too large for the boot partition
    mkdir -p "${esp_tmp_dir}${capsule_dir}"
    gunzip -k -c ${bootloader_blob} | dd of="${esp_tmp_dir}${capsule_dir}TEGRA_BL.Cap"
    sync
    umount $esp_dev
    rm -rf $esp_tmp_dir || true
    write_jetson_update_efivars
}

do_legacy_update() {
    bootloader_blob="/tmp/boot0.img"
    mtdblock="/dev/mtdblock0"
    gunzip -k -c /opt/tegra-binaries/boot0.img.gz > $bootloader_blob
    existing_bootloader_md5sum=$(dd if=$mtdblock bs=1M status=none | md5sum | awk '{print $1}')
    update_bootloader_md5sum=$(md5sum $bootloader_blob | awk '{print $1}')

    if [ ! "$existing_bootloader_md5sum" = "$update_bootloader_md5sum" ]; then
        info "Will clear bootloader device before legacy mode update"
	mtd_debug erase /dev/mtd0 0x0 0x4000000 || true
        info "Updating bootloader device in legacy mode update"
	mtd_debug write /dev/mtd0 0x0 0x4000000 $bootloader_blob
        info "Updated bootloader device in legacy mode update"
    else
        info "No need to update bootloader device"
    fi
}

info "Pre-update A/B slots info:"
info "=========================="
/usr/sbin/nvbootctrl dump-slots-info || true
info "=========================="

# In some cases of switching back and forth
# between 35.4.1 and 35.5.0, i.e rollback altboot
# the alternate slot may become corrupt
# and the MB2 precompiled bootloader will refuse
# to boot from the alternate slot, will fallback
# to the previous one and also future capsule
# updates will not work. In this case, we
# have to fall back to the legacy update mode
# which implies erasing and re-writing the
# QSPI. Example MB2 logs for this scenario:
# I> Successfully register XUSB FW load task with MB2 loader
# I> Active chain: 1
# I> Partition name: B_spe-fw
# E> Cannot find partition B_spe-fw
# E> Partition B_spe-fw not found
# E> MB2_FW_LOAD: Failed to load FW.
# C> Task 0x0 failed (err: 0x224d090d)
# E> Top caller module: LOADER, error module: PARTITION_MANAGER, reason: 0x0d, aux_info: 0x09
if [ "$DURING_UPDATE" = "1" ]; then
    check_corrupted_slots
fi

if [ $use_capsule -eq 1 ]; then
    do_capsule_update
    check_and_update_esp_flags
else
    do_legacy_update
fi
